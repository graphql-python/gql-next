from typing import cast
from graphql import GraphQLSchema, GraphQLWrappingType, GraphQLNonNull, OperationDefinitionNode, NonNullTypeNode, TypeNode

from gql.config import Config
from gql.utils_codegen import CodeChunk
from gql.query_parser import ParsedQuery, MappingNode




CLASS_TEMPLATE = """
@dataclass_json
@dataclass(frozen=True)
"""


class DataclassesRenderer:

    def __init__(self, schema: GraphQLSchema, config: Config):
        self.schema = schema
        self.config = config

    def render(self, parsed_data: ParsedQuery):
        # We sort fragment nodes to be first and operations to be last because of dependecies
        sorted_data = sorted(parsed_data.parsed, key=lambda node: 1 if node.node.kind == 'operation_definition' else 0)

        buffer = CodeChunk()
        buffer.write('# AUTOGENERATED file. Do not Change!')
        buffer.write('from typing import Any, Callable, Mapping')
        buffer.write('from dataclasses import dataclass')
        buffer.write('from dataclasses_json import dataclass_json')
        buffer.write('from gql.clients import Client, AsyncIOClient')

        if self.config.custom_header:
            buffer.write_lines(self.config.custom_header.split('\n'))

        for node in sorted_data:
            self.__do_render(buffer, node)

        return str(buffer)

    def render_common(self):
        # pylint:disable=no-self-use
        return ''

    def __do_render(self, buffer: CodeChunk, node: MappingNode):
        if node.node.kind == 'operation_definition':
            self.__render_operation(buffer, node)

        elif node.node.kind == 'fragment_definition':
            self.__render_python_class(buffer, node)

        elif node.node.kind == 'field':
            self.__render_field(buffer, node)

    def __render_field(self, buffer: CodeChunk, node: MappingNode):
        field_typename = self.__scalar_type_to_python(node.graphql_type)

        if node.children or node.fragments:
            self.__render_python_class(buffer, node)

        buffer.write(f'{node.name}: {field_typename}')


    def __render_operation(self, buffer: CodeChunk, node: MappingNode):
        assert node.node.kind == 'operation_definition'
        graphql_node = cast(OperationDefinitionNode, node.node)
        op_name = f'{graphql_node.operation.value.capitalize()}{graphql_node.name.value}'

        buffer.write('@dataclass_json')
        buffer.write('@dataclass')
        with buffer.write_block('class {name}:', name=op_name):
            buffer.write('__QUERY__ = """')
            buffer.write(node.query)
            buffer.write('"""')
            buffer.write('')

            self.__render_python_class(buffer, node)

            buffer.write(f'data: {node.name} = None')
            buffer.write('errors: Any = None')
            buffer.write('')

            # Execution functions
            variables = [(var_def.variable.name.value, self.__variable_type_to_python(var_def.type))
                         for var_def in
                         graphql_node.variable_definitions]

            if variables:
                vars_args = ', '.join([f'{vdef.variable.name.value}: {self.__variable_type_to_python(vdef.type)}' for vdef in graphql_node.variable_definitions]) + ','
                variables_dict = '{' + ', '.join(f'"{name}": {name}' for name, _ in variables) + '}'
            else:
                vars_args = ''
                variables_dict = 'None'

            buffer.write('@classmethod')
            with buffer.write_block(f'def execute(cls, {vars_args} on_before_callback: Callable[[Mapping[str, str], Mapping[str, str]], None] = None):'):
                buffer.write(f'client = Client(\'{self.config.schema}\')')
                buffer.write(f'variables = {variables_dict}')
                buffer.write('response_text = client.call(cls.__QUERY__, variables=variables, on_before_callback=on_before_callback)')
                buffer.write('return cls.from_json(response_text)')

            buffer.write('@classmethod')
            with buffer.write_block(f'async def execute_async(cls, {vars_args} on_before_callback: Callable[[Mapping[str, str], Mapping[str, str]], None] = None):'):
                buffer.write(f'client = AsyncClient(\'{self.config.schema}\')')
                buffer.write(f'variables = {variables_dict}')
                buffer.write(f'response_text = await client.call(cls.__QUERY__, variables=variables, on_before_callback=on_before_callback)')
                buffer.write(f'return cls.from_json(response_text)')

    def __render_python_class(self, buffer: CodeChunk, node: MappingNode):
        graphql_type = node.graphql_type if not isinstance(node.graphql_type, GraphQLWrappingType) else node.graphql_type.of_type
        name = node.name if node.node.kind in ['operation_definition', 'fragment_definition'] else str(graphql_type)

        buffer.write('@dataclass_json')
        buffer.write('@dataclass')
        with buffer.write_block(f'class {name}({",".join(node.fragments)}):'):
            if node.children:
                for child in node.children:
                    self.__do_render(buffer, child)
            else:
                # Class has no fields of its own, only derive from fragment
                buffer.write('pass')

    @staticmethod
    def __scalar_type_to_python(scalar, default=None):
        nullable = True
        if isinstance(scalar, GraphQLNonNull):
            nullable = False
            scalar = scalar.of_type

        mapping = {
            'ID': 'str',
            'String': 'str',
            'Int': 'int',
            'Float': 'float',
            'Boolean': 'bool',
            'DateTime': 'str'  # TODO: add config for custom mapping of scalar -> custom python type
        }

        default = default or scalar
        mapping = mapping.get(str(scalar), default)
        return mapping if not nullable else f'{mapping} = None'

    @staticmethod
    def __variable_type_to_python(vartype: TypeNode):
        nullable = True
        if isinstance(vartype, NonNullTypeNode):
            nullable = False
            vartype = vartype.type

        mapping = {
            'ID': 'str',
            'String': 'str',
            'Int': 'int',
            'Float': 'float',
            'Boolean': 'bool',
            'DateTime': 'str'
        }

        mapping = mapping.get(vartype.name.value, 'str')
        return mapping if not nullable else f'{mapping} = None'
